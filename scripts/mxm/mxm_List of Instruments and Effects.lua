-- @description List of Instruments and Effects
-- @author Michal MaXyM Bartak
-- @version 2.0
-- @licence GPL v3
-- @about
--   # About
--   The script generates list of plugins used in the project
-- 
--   It's written and tested in Reaper7.x. Might work in previous versions too.
-- 
--  * REAPER: 7.0
--  * Extensions: Lokasenna_GUI, lib_path_v2
-- @changelog
--   v2.0 Added GUI with export to plain text and markdown
--   v1.0 Initial version


-- PART - Script generated by Lokasenna's GUI Builder
local lib_path = reaper.GetExtState("Lokasenna_GUI", "lib_path_v2")
if not lib_path or lib_path == "" then
    reaper.MB("Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List.", "Whoops!", 0)
    return
end

loadfile(lib_path .. "Core.lua")()
GUI.req("Classes/Class - Textbox.lua")()
GUI.req("Classes/Class - TextEditor.lua")()
GUI.req("Classes/Class - Button.lua")()
-- If any of the requested libraries weren't found, abort the script.
if missing_lib then return 0 end


GUI.name = "New script GUI"
GUI.x, GUI.y, GUI.w, GUI.h = 0, 0, 512, 480
GUI.anchor, GUI.corner = "mouse", "C"

-- End of Lokasenna's GUI Builder PART



local function IsInstrument(track, fx_id)
-- RETURNS TRUE IF FX at fx_id is an instrument

  if track == nil then return end
  local ok, rv = reaper.TrackFX_GetNamedConfigParm(track, fx_id, 'fx_type')
  return ok and rv:find('.*i$') and true or false
end

local function PadColumn(content, len)
  local s
  s = content
  s = s .. string.rep(" ", len-string.len(s))

  return s
end

function spairs(t, order)
    -- sort array function
    -- found on page: https://stackoverflow.com/a/15706820

    -- collect the keys
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end

    -- if order function given, sort by it by passing the table and keys a, b,
    -- otherwise just sort the keys
    if order then
        table.sort(keys, function(a,b) return order(t, a, b) end)
    else
        table.sort(keys)
    end

    -- return the iterator function
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end


local function PrintTableMarkup(table)
  local msg = ""
  local maxnamewidth = 0
  local quantitywidth = 10

  for instrument, quantity in pairs(table) do
      maxnamewidth = math.max(maxnamewidth, string.len(instrument))
  end

  msg = msg .. "|" .. PadColumn("Plugin Name", maxnamewidth)
  msg = msg .. "|" .. PadColumn("Instances", quantitywidth) .. "|\n"
  msg = msg .. "|" .. PadColumn( string.rep("-", maxnamewidth), maxnamewidth)
  msg = msg .. "|" .. PadColumn( string.rep("-", quantitywidth -1) .. ":", quantitywidth) .. "|\n"

  for instrument, quantity in spairs(table) do

      msg = msg .. "|" .. PadColumn(instrument, maxnamewidth)
      msg = msg .. "|" .. PadColumn(quantity, quantitywidth) .. "|\n"
  end

  return msg
end

local function PrintTable(intable)
  local msg = ""
  local found = false
  
  for instrument, quantity in pairs(intable) do
      msg = msg .. PadColumn(quantity .. "x ", 5) .. instrument .. "\n"
      found = true
  end
  
  if found then
    return msg
  else
    return "N/A\n"
  end
end


-- Get the active project
local project = reaper.EnumProjects(-1, "")
-- Initialize tables to store instrument and effect names and their quantities
MONITORINGIDX  = 0x1000000 -- needed to distinguish monitoring plugins chain

local function initArrays()
  instrumentList = {}
  effectList     = {}
  offlineList    = {}
  monitorinList  = {}
end

local function AssignToCategory(track, fxIndex)

    -- Get FX name
    local _, fxName = reaper.TrackFX_GetFXName(track, fxIndex, "")

    -- Get the enabled state of the plugin
    local isEnabled = reaper.TrackFX_GetEnabled(track, fxIndex)

    -- Get the offline state of the plugin
    local isOffline = reaper.TrackFX_GetOffline(track, fxIndex)

    -- If the plugin is enabled, check if it's an instrument or effect
    if isEnabled and not isOffline then

        if fxIndex >= MONITORINGIDX then
            monitorinList[fxName] = (monitorinList[fxName] or 0) + 1
        elseif  IsInstrument(track, fxIndex) then
            instrumentList[fxName] = (instrumentList[fxName] or 0) + 1
        else
            effectList[fxName] = (effectList[fxName] or 0) + 1
        end
    else
       offlineList[fxName] = (offlineList[fxName] or 0) + 1
    end

end

local function GenerateData()

  initArrays()
  -- Iterate through all tracks in the project
  for i = 0, reaper.CountTracks(project) - 1 do
      local track = reaper.GetTrack(project, i)
  
      -- Iterate through all FX on the track
      for fxIndex = 0, reaper.TrackFX_GetCount(track) - 1 do
           AssignToCategory(track, fxIndex)
      end
  end

  -- Get master track plugins
  local numMasterFX = reaper.TrackFX_GetCount(reaper.GetMasterTrack())
  
   -- Iterate through all FX on master track
  for fxIndex = 0, numMasterFX - 1 do
      AssignToCategory(reaper.GetMasterTrack(), fxIndex)
  end
  
  -- Get monitoring FXs
  local numinputFX = reaper.TrackFX_GetRecCount(reaper.GetMasterTrack())
  for fxIndex = 0, numinputFX - 1 do
      AssignToCategory(reaper.GetMasterTrack(), fxIndex+MONITORINGIDX)
  end

end

local function GetDataMarkup()
  GenerateData();
  -- Display the lists
  local msg = "**Instruments:**\n"
  msg = msg .. PrintTableMarkup(instrumentList)
  
  msg = msg .. "\n**Effects:**\n"
  msg = msg .. PrintTableMarkup(effectList)
  
  msg = msg .. "\n**Monitoring plugins:**\n"
  msg = msg .. PrintTableMarkup(monitorinList)
  
  msg = msg .. "\n**Offline/inactive plugins:**\n"
  msg = msg .. PrintTableMarkup(offlineList)
  
  return msg
end

local function GetDataPlain()
  GenerateData();
  -- Display the lists
  local msg = "Instruments:\n"
  msg = msg .. PrintTable(instrumentList)
  
  msg = msg .. "\nEffects:\n"
  msg = msg .. PrintTable(effectList)
  
  msg = msg .. "\nMonitoring plugins:\n"
  msg = msg .. PrintTable(monitorinList)
  
  msg = msg .. "\nOffline/inactive plugins:\n"
  msg = msg .. PrintTable(offlineList)
  
  return msg
end


function get_a() 
  reaper.ShowConsoleMsg(GetDataPlain());
  reaper.CF_SetClipboard(GetDataPlain());
  GUI.Val("TextEditor1", GetDataPlain());
end

function get_b() 
   reaper.ShowConsoleMsg(GetDataMarkup());
   reaper.CF_SetClipboard(GetDataMarkup());
   GUI.Val("TextEditor1", GetDataMarkup());
end

GUI.New("Button1", "Button", {
    z = 11,
    x = 24,
    y = 64,
    w = 70,
    h = 24,
    caption = "Plain Text",
    font = 3,
    col_txt = "txt",
    col_fill = "elm_frame",
    func = get_a
})

GUI.New("Button2", "Button", {
    z = 11,
    x = 125,
    y = 64,
    w = 70,
    h = 24,
    caption = "Markdown",
    font = 3,
    col_txt = "txt",
    col_fill = "elm_frame",
    func = get_b
    })

GUI.New("TextEditor1", "TextEditor", {
    z = 11,
    x = 24,
    y = 128,
    w = 460,
    h = 320,
    caption = "",
    font_a = 3,
    font_b = "monospace",
    color = "txt",
    col_fill = "elm_fill",
    cap_bg = "wnd_bg",
    bg = "elm_bg",
    shadow = true,
    pad = 4,
    undo_limit = 20
})


GUI.Init()
GUI.Main()
